// Generated by CoffeeScript 1.9.3
(function() {
  var TaskGroup, compact, docpadUtil, extractOptsAndCallback, pathUtil, ref, uniq, util,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    slice = [].slice;

  pathUtil = require('path');

  util = require('util');

  ref = require('underscore'), uniq = ref.uniq, compact = ref.compact;

  extractOptsAndCallback = require('extract-opts');

  TaskGroup = require('taskgroup').TaskGroup;


  /**
   * The DocPad Util Class.
   * Collection of DocPad utility methods
   * @class docpadUtil
   * @constructor
   * @static
   */

  module.exports = docpadUtil = {

    /**
    	 * Write to stderr
    	 * @private
    	 * @method writeStderr
    	 * @param {String} data
     */
    writeStderr: function(data) {
      var err;
      try {
        return process.stderr.write(data);
      } catch (_error) {
        err = _error;
        return process.stdout.write(data);
      }
    },

    /**
    	 * Write an error
    	 * @private
    	 * @method writeError
    	 * @param {Object} err
     */
    writeError: function(err) {
      var ref1;
      return docpadUtil.writeStderr(((ref1 = err.stack) != null ? typeof ref1.toString === "function" ? ref1.toString() : void 0 : void 0) || err.message || err);
    },

    /**
    	 * Wait. Wrapper for setTimeout
    	 * @private
    	 * @method wait
    	 * @param {Number} time
    	 * @param {function} fn
     */
    wait: function(time, fn) {
      return setTimeout(fn, time);
    },

    /**
    	 * Get Default Log Level
    	 * @private
    	 * @method getDefaultLogLevel
    	 * @return {Number} default log level
     */
    getDefaultLogLevel: function() {
      if (docpadUtil.isTravis() || (indexOf.call(process.argv, '-d') >= 0)) {
        return 7;
      } else {
        return 5;
      }
    },

    /**
    	 * Are we executing on Travis
    	 * @private
    	 * @method isTravis
    	 * @return {String} The travis node version
     */
    isTravis: function() {
      return process.env.TRAVIS_NODE_VERSION != null;
    },

    /**
    	 * Is this TTY
    	 * @private
    	 * @method isTTY
    	 * @return {Boolean}
     */
    isTTY: function() {
      var ref1, ref2;
      return ((ref1 = process.stdout) != null ? ref1.isTTY : void 0) === true && ((ref2 = process.stderr) != null ? ref2.isTTY : void 0) === true;
    },

    /**
    	 * Is Standadlone
    	 * @private
    	 * @method isStandalone
    	 * @return {Object}
     */
    isStandalone: function() {
      return /docpad$/.test(process.argv[1] || '');
    },

    /**
    	 * Is user
    	 * @private
    	 * @method isUser
    	 * @return {Boolean}
     */
    isUser: function() {
      return docpadUtil.isStandalone() && docpadUtil.isTTY() && docpadUtil.isTravis() === false;
    },

    /**
    	 * Wrapper for the node.js method util.inspect
    	 * @method inspect
    	 * @param {Object} obj
    	 * @param {Object} opts
    	 * @return {String}
     */
    inspect: function(obj, opts) {
      if (opts == null) {
        opts = {};
      }
      if (docpadUtil.isTTY()) {
        if (opts.colors == null) {
          opts.colors = indexOf.call(process.argv, '--no-colors') < 0;
        }
      } else {
        opts.colors = false;
      }
      return util.inspect(obj, opts);
    },

    /**
    	 * Are we using standard encoding?
    	 * @private
    	 * @method isStandardEncoding
    	 * @param {String} encoding
    	 * @return {Boolean}
     */
    isStandardEncoding: function(encoding) {
      var ref1;
      return (ref1 = encoding.toLowerCase()) === 'ascii' || ref1 === 'utf8' || ref1 === 'utf-8';
    },

    /**
    	 * Get Local DocPad Installation Executable - ie
    	 * not the global installation
    	 * @private
    	 * @method getLocalDocPadExecutable
    	 * @return {String} the path to the local DocPad executable
     */
    getLocalDocPadExecutable: function() {
      return pathUtil.join(process.cwd(), 'node_modules', 'docpad', 'bin', 'docpad');
    },

    /**
    	 * Is Local DocPad Installation
    	 * @private
    	 * @method isLocalDocPadExecutable
    	 * @return {Boolean}
     */
    isLocalDocPadExecutable: function() {
      var ref1;
      return ref1 = docpadUtil.getLocalDocPadExecutable(), indexOf.call(process.argv, ref1) >= 0;
    },

    /**
    	 * Does the local DocPad Installation Exist?
    	 * @private
    	 * @method getLocalDocPadExecutableExistance
    	 * @return {Boolean}
     */
    getLocalDocPadExecutableExistance: function() {
      return require('safefs').existsSync(docpadUtil.getLocalDocPadExecutable()) === true;
    },

    /**
    	 * Spawn Local DocPad Executable
    	 * @private
    	 * @method startLocalDocPadExecutable
    	 * @param {Function} next
    	 * @return {Object} don't know what
     */
    startLocalDocPadExecutable: function(next) {
      var args, command;
      args = process.argv.slice(2);
      command = ['node', docpadUtil.getLocalDocPadExecutable()].concat(args);
      return require('safeps').spawn(command, {
        stdio: 'inherit'
      }, function(err) {
        var message;
        if (err) {
          if (next) {
            return next(err);
          } else {
            message = 'An error occured within the child DocPad instance: ' + err.message + '\n';
            return docpadUtil.writeStderr(message);
          }
        } else {
          return typeof next === "function" ? next() : void 0;
        }
      });
    },

    /**
    	 * get a filename without the extension
    	 * @method getBasename
    	 * @param {String} filename
    	 * @return {String} base name
     */
    getBasename: function(filename) {
      var basename;
      if (filename[0] === '.') {
        basename = filename.replace(/^(\.[^\.]+)\..*$/, '$1');
      } else {
        basename = filename.replace(/\..*$/, '');
      }
      return basename;
    },

    /**
    	 * Get the extensions of a filename
    	 * @method getExtensions
    	 * @param {String} filename
    	 * @return {Array} array of string
     */
    getExtensions: function(filename) {
      var extensions;
      extensions = filename.split(/\./g).slice(1);
      return extensions;
    },

    /**
    	 * Get the extension from a bunch of extensions
    	 * @method getExtension
    	 * @param {Array} extensions
    	 * @return {String} the extension
     */
    getExtension: function(extensions) {
      var extension;
      if (!require('typechecker').isArray(extensions)) {
        extensions = docpadUtil.getExtensions(extensions);
      }
      if (extensions.length !== 0) {
        extension = extensions.slice(-1)[0] || null;
      } else {
        extension = null;
      }
      return extension;
    },

    /**
    	 * Get the directory path.
    	 * Wrapper around the node.js path.dirname method
    	 * @method getDirPath
    	 * @param {String} path
    	 * @return {String}
     */
    getDirPath: function(path) {
      return pathUtil.dirname(path) || '';
    },

    /**
    	 * Get the file name.
    	 * Wrapper around the node.js path.basename method
    	 * @method getFilename
    	 * @param {String} path
    	 * @return {String}
     */
    getFilename: function(path) {
      return pathUtil.basename(path);
    },

    /**
    	 * Get the DocPad out file name
    	 * @method getOutFilename
    	 * @param {String} basename
    	 * @param {String} extension
    	 * @return {String}
     */
    getOutFilename: function(basename, extension) {
      if (basename === '.' + extension) {
        return basename;
      } else {
        return basename + (extension ? '.' + extension : '');
      }
    },

    /**
    	 * Get the URL
    	 * @method getUrl
    	 * @param {String} relativePath
    	 * @return {String}
     */
    getUrl: function(relativePath) {
      return '/' + relativePath.replace(/[\\]/g, '/');
    },

    /**
    	 * Get the post slug from the URL
    	 * @method getSlug
    	 * @param {String} relativeBase
    	 * @return {String} the slug
     */
    getSlug: function(relativeBase) {
      return require('bal-util').generateSlugSync(relativeBase);
    },

    /**
    	 * Perform an action
    	 * next(err,...), ... = any special arguments from the action
    	 * this should be it's own npm module
    	 * as we also use the concept of actions in a few other packages.
    	 * Important concept in DocPad.
    	 * @method action
    	 * @param {Object} action
    	 * @param {Object} opts
    	 * @param {Function} next
     */
    action: function(action, opts, next) {
      var actionMethod, actionTaskOrGroup, actions, err, i, len, locale, me, ref1, ref2, ref3, run, runner, runnerTask, task;
      ref1 = extractOptsAndCallback(opts, next), opts = ref1[0], next = ref1[1];
      me = this;
      locale = me.getLocale();
      run = (ref2 = opts.run) != null ? ref2 : true;
      runner = (ref3 = opts.runner) != null ? ref3 : me.getActionRunner();
      if (Array.isArray(action)) {
        actions = action;
      } else {
        actions = action.split(/[,\s]+/g);
      }
      actions = uniq(compact(actions));
      if (actions.length === 0) {
        err = new Error(locale.actionEmpty);
        return next(err);
        me;
      }
      if (actions.length > 1) {
        actionTaskOrGroup = runner.createGroup('actions bundle: ' + actions.join(' '));
        for (i = 0, len = actions.length; i < len; i++) {
          action = actions[i];
          actionMethod = me[action].bind(me);
          if (!actionMethod) {
            err = new Error(util.format(locale.actionNonexistant, action));
            return next(err);
            me;
          }
          task = actionTaskOrGroup.createTask(action, actionMethod, {
            args: [opts]
          });
          actionTaskOrGroup.addTask(task);
        }
      } else {
        action = actions[0];
        actionMethod = me[action].bind(me);
        if (!actionMethod) {
          err = new Error(util.format(locale.actionNonexistant, action));
          return next(err);
          me;
        }
        actionTaskOrGroup = runner.createTask(action, actionMethod, {
          args: [opts]
        });
      }
      runnerTask = runner.createTask("runner task for action: " + action, function(continueWithRunner) {
        actionTaskOrGroup.done(function() {
          var args;
          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
          if (next) {
            next.apply(null, args);
            args[0] = null;
          }
          return continueWithRunner.apply(null, args);
        });
        return actionTaskOrGroup.run();
      });
      runner.addTask(runnerTask);
      if (run === true) {
        runner.run();
      }
      return me;
    }
  };

}).call(this);
